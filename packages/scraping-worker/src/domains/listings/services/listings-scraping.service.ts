import { Injectable, Logger } from '@nestjs/common';
import { NotaryScraperService } from './notary-scraper.service.js';
import { ListingsOpportunityRepository } from '../repositories/listings-opportunity.repository.js';
import type { ListingOpportunity } from '~/domains/listings/types/listings.types.js';
import type { Listing } from '@linkinvests/shared';

@Injectable()
export class ListingsScrapingService {
  private readonly logger = new Logger(ListingsScrapingService.name);

  constructor(
    private readonly notaryScraperService: NotaryScraperService,
    private readonly listingsOpportunityRepository: ListingsOpportunityRepository
  ) {}

  async processNotaryListings(
    startPage?: number,
    endPage?: number
  ): Promise<void> {
    const jobStartTime = new Date();
    let totalListings = 0;
    let savedListings = 0;
    let listingsWithImages = 0;
    let geocodedListings = 0;

    try {
      this.logger.log('Starting listings scraping job');

      // Scrape listings from notary website
      const opportunities =
        await this.notaryScraperService.scrapeNotaryListings(
          startPage,
          endPage
        );
      totalListings = opportunities.length;

      if (opportunities.length === 0) {
        this.logger.warn(
          'No opportunities scraped, job completed with no data'
        );
        return;
      }

      // Collect quality metrics
      geocodedListings = opportunities.filter(
        (opp) => opp.latitude && opp.longitude
      ).length;

      listingsWithImages = opportunities.filter(
        (opp) => opp.images && opp.images.length > 0
      ).length;

      this.logger.log(
        {
          totalOpportunities: opportunities.length,
          geocoded: geocodedListings,
          withImages: listingsWithImages,
          geocodingRate: Math.round(
            (geocodedListings / opportunities.length) * 100
          ),
          imagesRate: Math.round(
            (listingsWithImages / opportunities.length) * 100
          ),
        },
        'Quality metrics collected'
      );

      // Convert domain types to shared types for database
      const listingsForDb = this.convertToSharedTypes(opportunities);

      // Save opportunities to database
      this.logger.log('Saving opportunities to database');
      await this.listingsOpportunityRepository.insertListings(listingsForDb);
      savedListings = opportunities.length;

      const jobEndTime = new Date();
      const jobDuration = jobEndTime.getTime() - jobStartTime.getTime();

      this.logger.log(
        {
          totalListings,
          savedListings,
          geocodedListings,
          listingsWithImages,
          jobDurationMs: jobDuration,
          jobDurationMinutes: Math.round(jobDuration / 60000),
        },
        'Listings scraping job completed successfully'
      );
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      const jobEndTime = new Date();
      const jobDuration = jobEndTime.getTime() - jobStartTime.getTime();

      this.logger.error(
        {
          error: errorMessage,
          totalListings,
          savedListings,
          geocodedListings,
          listingsWithImages,
          jobDurationMs: jobDuration,
        },
        'Listings scraping job failed'
      );

      // Re-throw to mark job as failed in BullMQ
      throw error;
    }
  }

  /**
   * Convert domain ListingOpportunity to shared Listing type
   */
  private convertToSharedTypes(opportunities: ListingOpportunity[]): Listing[] {
    return opportunities.map((opp) => ({
      // Base opportunity fields
      id: '', // Will be generated by database
      label: opp.label,
      source: opp.source,
      address: opp.address ?? `${opp.city} ${opp.zipCode ?? opp.department}`,
      zipCode: opp.zipCode,
      department: opp.department,
      latitude: opp.latitude,
      longitude: opp.longitude,
      opportunityDate: opp.opportunityDate.toISOString().split('T')[0],
      externalId: opp.externalId,
      url: opp.url,
      createdAt: new Date(),
      updatedAt: new Date(),

      // Listing-specific fields
      propertyType: opp.propertyType,
      description: opp.description,
      squareFootage: opp.squareFootage,
      landArea: opp.landArea,
      rooms: opp.rooms,
      bedrooms: opp.bedrooms,
      energyClass: opp.energyClass,
      constructionYear: opp.constructionYear,
      floor: opp.floor,
      totalFloors: opp.totalFloors,
      balcony: opp.balcony,
      terrace: opp.terrace,
      garden: opp.garden,
      garage: opp.garage,
      parking: opp.parking,
      elevator: opp.elevator,

      // Price fields
      price: opp.price,
      priceType: opp.priceType,
      fees: undefined, // Domain type doesn't have this
      charges: undefined, // Domain type doesn't have this

      // Picture fields
      mainPicture: opp.images?.[0],
      pictures: opp.images?.slice(1) || [],
      isSoldRented: false,
      sellerType: 'professional',
      // Convert notaryOffice to sellerContact
      sellerContact: opp.notaryOffice
        ? {
            name: opp.notaryOffice.name,
            address: opp.notaryOffice.address,
            phone: opp.notaryOffice.phone,
            email: opp.notaryOffice.email,
            website: opp.notaryOffice.website,
            contact: opp.notaryOffice.contact,
            siret: undefined, // Domain type doesn't have this
          }
        : undefined,
    }));
  }
}
